# File generated by Wizard 2.9.0 on Jun 24, 2025. # 向导生成文件标头

processor  WEAPON_RELEASE WSF_SCRIPT_PROCESSOR  # 定义脚本处理器：武器释放逻辑
   update_interval  1 s # 更新周期1秒
   script_variables  # 脚本变量区
      string weaponName = ""; # 武器名称，由外部初始化
      Map<string,bool> isEngage = Map<string,bool>();  # 已交战目标标记表
      int engagaCount = 5; # 每次循环最多检查的航迹数量
   end_script_variables # 结束变量区
   
   script bool fireEnemy(WsfTrack tTrack, string wpName){ # 函数：对目标开火
      bool isSuccess = false; # 结果标志
      WsfWeapon tempWeapon = PLATFORM.Weapon(wpName); # 获取武器句柄
      if(tempWeapon.IsValid()
      && tempWeapon.QuantityRemaining()>0
      && PLATFORM.Altitude() > 9000
      && tempWeapon.AuxDataDouble("strikeDistance") > PLATFORM.GroundRangeTo(tTrack)){
        isSuccess = tempWeapon.FireSalvo(tTrack,1); # 齐射发射1枚
        writeln("T = ",TIME_NOW,",`",PLATFORM.Name() ,"`  launches the missile `",wpName,"` to bomb `", tTrack.TargetName(),"` with isSuccess = ",isSuccess); # 记录日志
      }
      return isSuccess; # 返回是否成功
   }
   end_script # 结束脚本段
   
   on_update  # 周期性更新回调
      WsfLocalTrackList track_list = PLATFORM.MasterTrackList(); # 获取主航迹列表
#      int track_count = track_list.Count(); # 航迹数量（保留注释）
      for(int i = 0; i < engagaCount; i += 1 ){ # 遍历前N条航迹
         WsfTrack tTrack = track_list.TrackEntry(i); # 取第i条
         if(!tTrack.IsValid())continue; # 无效则跳过
         string track_name = tTrack.TargetName(); # 获取目标名
         if(isEngage[track_name])continue; # 已交战则跳过
         if(!fireEnemy(tTrack,weaponName))continue; # 若发射失败则跳过
            isEngage[track_name] = true;  # 标记已交战
      }
   end_on_update # 结束更新回调
end_processor # 结束处理器